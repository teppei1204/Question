整数型:x←1
整数型:y←2
整数型:z←3
x←x+1
y←x-1
z←z+x+1
zの値を出力する      A_6
<!-- 変数とは -->
  具体的な数値(1.2.3)や文字("あ","い","う")等を格納しておく箱のこと。
変数には型が存在し、格納する値に制限をかけることができる。
変数の方はプログラミング言語によって種類が異なる。
<!-- 変数を使用するメリット -->
  同じ値の記述は一回でOK。円周と円の面積を求めるプログラムを考える。

[プログラム]
実数型:hankei ← 10.00
実数型:pi ← 3.14
実数型:enshu = (hankei * 2) * pai<!--直径✖️π-->
実数型:menseki = hankei * hankei * pai <!--半径✖️半径✖️π-->

実数型の変数hankeiとpiを宣言して値を格納しておくことで、円周と円の面積を求める際に必要な「10」と「3.14」が一回でOK。
何回も同じ値を使う際、具体的な値を書く(ハードコードコーディング)回数は極力するなくすることが好まれる。プログラム修正の手間を減らす為。

[プログラム]
文字列型:a←"123"
文字列型:b←"45"
文字列型:c
c ← a + b <!--cにはaとbを文字列結合した"12345"が格納される-->

方を指定しない場合、a + bの計算が数値とみなされてcに123 + 45 = 168が格納されてしまう可能性がある。
変数に適切な型を指定しておくことが重要。
<!-- 応用 -->
[プログラム]
文字列型:x←"1"
文字列型:y←"2"
文字列型:z←"3"
x←"4"
y←x + "5"
z←x + y
zの値を出力する      A_"445"

<!--条件分岐のif文-->
関数checkCoinは、引数で与えられた値に応じて"OK"か"NG"を出す。
1,5は"NG",10,50,100は"OK",500は"NG"である。

[プログラム]
○文字列型:checkCoin(整数型: money)
文字列型:result
if(moneyが10または50または100)
  result ← "OK"
  [a]([b])
  result ← "NG"
else
  result ← "OKでもNGでもない"
endif
return result      A_[a] elseif  /  [b] moneyが10または5または500

<!-- 応用 -->
関数checkNumは、引数の値に応じて文字列を返す。
値が2の倍数で4の倍数でないなら"2の倍数"、2の倍数でかつ4の倍数なら"2の倍数かつ4の倍数"、
これらに合致しない場合は"2の倍数でも4の倍数でもない"と返す。
但し値が負の数である場合は無条件で"負の数である"と返す。

[プログラム]
○文字列型: checkNum(整数型: num)
文字列型: result

if(numが[a])
  result ← "[a]"
elseif(numが[b])
  result ← "[b]"
elseif(numが[c])
  result ← "[c]"
else
  result ← "2の倍数でも4の倍数でもない"
endif

return result       A_[a] 負の数  /  [b] 2の倍数でかつ4の倍数  /  [c] 2の倍数

問題文とプログラムをリンクさせて考える

値が2の倍数で4の倍数でないなら"2の倍数"                   ①
2の倍数でかつ4の倍数なら"2の倍数かつ4の倍数"               ②
これらに合致しない場合は"2の倍数でも4の倍数でもない"と返す。  ③
但し値が負の数である場合は無条件で"負の数である"と返す。     ④

if文で複数の条件分岐を記載する時は優先順位を整理する。
※2つ目以降の条件には「elseif」がついており、「上記以外でかつ〇〇の場合」という前提がつくため。
"無条件で"と記載がある④が1番目、プログラム上に既に記載ある③は4番目となる。

<!-- 配列 -->

関数printArrayDataをprintArrayData(3,{3,4,5,6})として呼び出すと○が出力される。

[プログラム]
○文字列型: printArrayData(整数型: i,整数型の配列: data)

if(iがdataの要素数以下である)
  data[i]の値を出力する
else
  "配列の要素数より大きい値が指定されています"と出力する
endif
A_5

<!-- 配列とは -->
具体的な数値(1,2,3)や文字("あ","い","う")等について
複数のデータをまとめて格納しておく集まりのこと。
配列の特徴として、値を取り出す際には番号を指定する。
<!-- 配列を使用するメリット -->
変数をたくさん使わなくて済む
例としてクラスの生徒の名前を出力するプログラムを考える。

[プログラム]
文字列型の配列: students ← {"saito","sato","tanaka"}
students[1]の値を出力する //saitoと出力される
students[2]の値を出力する //satoと出力される
students[3]の値を出力する //tanakaと出力される

配列を使用しないで上記プログラムを実行する場合、変数を三つ宣言する必要があるが、配列であれば一つだけ宣言すれば良い。
扱うデータ量が増えると変数だけで実現するのは非常に難しく、プログラムも読みづらいため配列はプログラミングで必須である。

<!-- 応用 -->

関数printArrayDataをprintArrayData(2,1{{3,2},{3,4},{1,7},{5,5}})として呼び出すと○が出力される。

[プログラム]
○文字列型: printArrayData(整数型: i,整数型: j,整数型の配列の配列: data)
文字列型: errorMsg ← "配列の要素数より大きい値が指定されています"

if(iがdataの要素数以下である)
  if(jがdata[i]の要素数以下である)
    data[i][j]の値を出力する
  else
    errorMsgの値を出力する
  endif
else
  errorMsgの値を出力する
endif
A_3

<!-- 二次元配列とは -->

要素が配列となっている配列のこと。
二次元配列も通常の配列の同様、値を取り出す際には番号を指定する。

配列の名前[1][4]
[1]   1番目の大きい箱に格納されている整数型配列の
[4]   4番目の小さい箱に格納されている値