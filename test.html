整数型:x←1
整数型:y←2
整数型:z←3
x←x+1
y←x-1
z←z+x+1
zの値を出力する      A_6
<!-- 変数とは -->
  具体的な数値(1.2.3)や文字("あ","い","う")等を格納しておく箱のこと。
変数には型が存在し、格納する値に制限をかけることができる。
変数の方はプログラミング言語によって種類が異なる。
<!-- 変数を使用するメリット -->
  同じ値の記述は一回でOK。円周と円の面積を求めるプログラムを考える。

[プログラム]
実数型:hankei ← 10.00
実数型:pi ← 3.14
実数型:enshu = (hankei * 2) * pai<!--直径✖️π-->
実数型:menseki = hankei * hankei * pai <!--半径✖️半径✖️π-->

実数型の変数hankeiとpiを宣言して値を格納しておくことで、円周と円の面積を求める際に必要な「10」と「3.14」が一回でOK。
何回も同じ値を使う際、具体的な値を書く(ハードコードコーディング)回数は極力するなくすることが好まれる。プログラム修正の手間を減らす為。

[プログラム]
文字列型:a←"123"
文字列型:b←"45"
文字列型:c
c ← a + b <!--cにはaとbを文字列結合した"12345"が格納される-->

方を指定しない場合、a + bの計算が数値とみなされてcに123 + 45 = 168が格納されてしまう可能性がある。
変数に適切な型を指定しておくことが重要。
<!-- 応用 -->
[プログラム]
文字列型:x←"1"
文字列型:y←"2"
文字列型:z←"3"
x←"4"
y←x + "5"
z←x + y
zの値を出力する      A_"445"

<!--条件分岐のif文-->
関数checkCoinは、引数で与えられた値に応じて"OK"か"NG"を出す。
1,5は"NG",10,50,100は"OK",500は"NG"である。

[プログラム]
○文字列型:checkCoin(整数型: money)
文字列型:result
if(moneyが10または50または100)
  result ← "OK"
  [a]([b])
  result ← "NG"
else
  result ← "OKでもNGでもない"
endif
return result      A_[a] elseif  /  [b] moneyが10または5または500

<!-- 応用 -->
関数checkNumは、引数の値に応じて文字列を返す。
値が2の倍数で4の倍数でないなら"2の倍数"、2の倍数でかつ4の倍数なら"2の倍数かつ4の倍数"、
これらに合致しない場合は"2の倍数でも4の倍数でもない"と返す。
但し値が負の数である場合は無条件で"負の数である"と返す。

[プログラム]
○文字列型: checkNum(整数型: num)
文字列型: result

if(numが[a])
  result ← "[a]"
elseif(numが[b])
  result ← "[b]"
elseif(numが[c])
  result ← "[c]"
else
  result ← "2の倍数でも4の倍数でもない"
endif

return result       A_[a] 負の数  /  [b] 2の倍数でかつ4の倍数  /  [c] 2の倍数

問題文とプログラムをリンクさせて考える

値が2の倍数で4の倍数でないなら"2の倍数"                   ①
2の倍数でかつ4の倍数なら"2の倍数かつ4の倍数"               ②
これらに合致しない場合は"2の倍数でも4の倍数でもない"と返す。  ③
但し値が負の数である場合は無条件で"負の数である"と返す。     ④

if文で複数の条件分岐を記載する時は優先順位を整理する。
※2つ目以降の条件には「elseif」がついており、「上記以外でかつ〇〇の場合」という前提がつくため。
"無条件で"と記載がある④が1番目、プログラム上に既に記載ある③は4番目となる。

<!-- 配列 -->

関数printArrayDataをprintArrayData(3,{3,4,5,6})として呼び出すと○が出力される。

[プログラム]
○文字列型: printArrayData(整数型: i,整数型の配列: data)

if(iがdataの要素数以下である)
  data[i]の値を出力する
else
  "配列の要素数より大きい値が指定されています"と出力する
endif
A_5

<!-- 配列とは -->
具体的な数値(1,2,3)や文字("あ","い","う")等について
複数のデータをまとめて格納しておく集まりのこと。
配列の特徴として、値を取り出す際には番号を指定する。
<!-- 配列を使用するメリット -->
変数をたくさん使わなくて済む
例としてクラスの生徒の名前を出力するプログラムを考える。

[プログラム]
文字列型の配列: students ← {"saito","sato","tanaka"}
students[1]の値を出力する //saitoと出力される
students[2]の値を出力する //satoと出力される
students[3]の値を出力する //tanakaと出力される

配列を使用しないで上記プログラムを実行する場合、変数を三つ宣言する必要があるが、配列であれば一つだけ宣言すれば良い。
扱うデータ量が増えると変数だけで実現するのは非常に難しく、プログラムも読みづらいため配列はプログラミングで必須である。

<!-- 応用 -->

関数printArrayDataをprintArrayData(2,1{{3,2},{3,4},{1,7},{5,5}})として呼び出すと○が出力される。

[プログラム]
○文字列型: printArrayData(整数型: i,整数型: j,整数型の配列の配列: data)
文字列型: errorMsg ← "配列の要素数より大きい値が指定されています"

if(iがdataの要素数以下である)
  if(jがdata[i]の要素数以下である)
    data[i][j]の値を出力する
  else
    errorMsgの値を出力する
  endif
else
  errorMsgの値を出力する
endif
A_3

<!-- 二次元配列とは -->

要素が配列となっている配列のこと。
二次元配列も通常の配列の同様、値を取り出す際には番号を指定する。

配列の名前[1][4]
[1]   1番目の大きい箱に格納されている整数型配列の
[4]   4番目の小さい箱に格納されている値

<!-- 関数呼び出し① -->

関数printCalcDataをprintCalcData(6.3)として呼び出すと○が出力される。

[プログラム①]

○戻り値なし:printCalcData(整数型:a,整数型:b)

printAddData(a,b)
","を出力する
printSubData(a,b)
","を出力する
printMulData(a,b)

[プログラム②]

○戻り値なし:printAddData(整数型:a,整数型:b)
  (a + b)の値を出力する
○戻り値なし:printSubData(整数型:a,整数型:b)
  (a - b)の値を出力する
○戻り値なし:printAddData(整数型:a,整数型:b)
  (a * b)の値を出力する
A_9,3,18

<!-- 関数とは -->

よく利用する汎用的な処理をいつでも使えるように定義したもの
処理に必要な値を渡すと、その値を使って処理を実行して処理結果を返す。

<!-- 関数のメリット -->

激ムズだったり超重要な汎用的な処理を関数として作っておくことで
個々の開発者（プログラマー）は関数を使うだけで開発を進めることができる。

汎用的な処理を関数として作っておくことでプログラムの保守性が高まる。
関数を使わない場合、個々の愛発者が同じようなプログラムを別の場所に書くことになり、
プログラムを変更する際にたくさんの箇所を変更しなければいけなくなる。この状態を保守性が低いという。

<!-- 関数のオーソドックスな定義方法 -->

○戻り値の型:関数名(引数1の型:引数1,引数2の型:引数2,...引数nの型:引数n)

[関数定義の例]引数で渡された整数を自乗した値を返すメソッド
○整数型:calcSquare(整数型:number)
return number * number

<!-- 戻り値 -->
関数内で「return ○○○」と記載すると、処理を終了して呼び出し元に「○○○」の値を返すことができる。
この「○○○」を戻り値といい、その型を定義している。

<!-- (引数1の型:引数1,引数2の型:引数2,...引数nの型:引数n) -->
関数の中で処理に使用する値を呼び出し元から渡すことができる。
その方と変数名を引数の数だけ記載する。

<!-- 関数の呼び出し方法 -->

[例1]戻り値をプログラム内で使用する場合
  整数型:result ← calcSquare(2)  //変数resultに2 * 2 = 4が格納される
[例2]戻り値をプログラム内で使用しない場合
  整数型:a ← 2
  calcSquare(a)  //calcSquare内で2 * 2は計算されるがこのプログラム内で結果が使えない
[例3]戻り値をそのまま計算で使用する場合
  整数型:result ← calcSquare(2) * calcSquare(2)
  //変数resultに(2 * 2) * (2 * 2) = 16が格納される

関数を呼び出す際は定義した名前と、定義したい奇数に合わせた具体的な値を使用する。
また、戻り値を呼び出し元で使用する場合は戻り値を格納する変数の型が適切なものとなっていることにも注意する。

<!-- 関数呼び出し② -->

関数calcCombination は 正の整数 x と y を受け取り、組み合わせの数xCyの計算結果を返す。
関数getFactorialは第一引数に正の整数aを受け取り、aの階乗(a!)を整数型で返す。
ここでxCy = (x!/(y!*(x-y)!))である。

[プログラム]

○整数型:calcCombination(整数型:x,整数型:y)
  return [a]
A_getFactorial(x) / (getFactorial(y) * getFactorial(x-y))